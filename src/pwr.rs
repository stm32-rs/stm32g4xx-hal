//! Power configuration
//!
//! This module configures the PWR unit to provide the core voltage `VCORE`. The
//! voltage scaling mode is VOS1 (High Performance) by default, but VOS2, VOS3
//! and [VOS0](#boost-mode-vos0) can also be selected.
//!
//! When the system starts up, it is in Run* mode. After the call to
//! `freeze`, it will be in Run mode. See RM0433 Rev 7 Section 6.6.1
//! "System/D3 domain modes".
//!
//! There is a Boost Mode that allows higher clock speeds.
//!
//! Adapted from stm32h7xx-hal

use crate::stm32::PWR;

/// Extension trait that constrains the `PWR` peripheral
pub trait PwrExt {
    fn constrain(self) -> Pwr;
}

impl PwrExt for PWR {
    fn constrain(self) -> Pwr {
        Pwr {
            vos: VoltageScale::Range1 {
                enable_boost: false,
            },
        }
    }
}

/// Constrained PWR peripheral
///
/// Generated by calling `constrain` on the PAC's PWR peripheral.
pub struct Pwr {
    pub(crate) vos: VoltageScale,
}

impl Pwr {
    /// Set voltage scale
    ///
    /// See [`VoltageScale`]
    pub fn vos(mut self, vos: VoltageScale) -> Self {
        self.vos = vos;

        self
    }
    pub fn freeze(self) -> PowerConfiguration {
        let Self { vos } = self;
        PowerConfiguration { vos }
    }
}

/// Voltage Scale
///
/// Represents the voltage range feeding the CPU core. The maximum core
/// clock frequency depends on this value.
///
/// The device will start up with Range1{ enable_boost: false } as default
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VoltageScale {
    /// Voltage range 1
    ///
    /// Max clock speeds in range1
    ///
    /// | Clock source |  No boost    |   Boost    |
    /// |--------------|--------------|------------|
    /// |          HSI |        16MHz |      16MHz |
    /// |          HSE |        48MHz |      48MHz |
    /// |          PLL |       150MHz |     170MHz |
    ///
    /// The device will start up with Range1{ enable_boost: false } as default
    Range1 { enable_boost: bool },

    /// Voltage range 2
    ///
    /// | Clock source | Clock speed  |
    /// |--------------|--------------|
    /// |          HSI |        16MHz |
    /// |          HSE |        26MHz |
    /// |          PLL |        26MHz |
    Range2,
}

/// Power Configuration
///
/// Generated when the PWR peripheral is frozen. The existence of this
/// value indicates that the voltage scaling configuration can no
/// longer be changed.
pub struct PowerConfiguration {
    pub(crate) vos: VoltageScale,
}

impl PowerConfiguration {
    /// Gets the `VoltageScale` which was configured by `Pwr::freeze()`.
    pub fn vos(&self) -> VoltageScale {
        self.vos
    }
}

/// Returns the voltage scale at the current moment
pub(crate) fn current_vos() -> VoltageScale {
    // NOTE(unsafe): Read-only access
    let pwr = unsafe { &*PWR::ptr() };

    match pwr.cr1.read().vos().bits() {
        0b00 => unreachable!(),
        0b01 => VoltageScale::Range1 {
            enable_boost: pwr.cr5.read().r1mode().bit(),
        },
        0b10 => VoltageScale::Range2,
        0b11 => unreachable!(),
        _ => unreachable!(),
    }
}

/// Set new voltage scale and wait for ready
///
/// NOTE: Does not apply the boost mode
///
/// SAFETY: Caller has to ensure we are in a valid frequency range, wait states etc to enter the new voltage range
/// and that the correct sequence is respected (see 'Dynamic voltage scaling management' in RM0440). Also ensure unique
/// access of PWR peripheral
#[allow(dead_code)]
pub(crate) unsafe fn set_vos(vos: VoltageScale) {
    let pwr = unsafe { &*PWR::ptr() };

    let vos = match vos {
        VoltageScale::Range1 { .. } => 0b01,
        VoltageScale::Range2 => 0b10,
    };
    pwr.cr1.modify(|_r, w| w.vos().bits(vos));

    // Wait for ready
    while pwr.sr2.read().vosf().bit() {}
}

/// Set new voltage scale
///
/// SAFETY: Caller has to ensure we are in a valid frequency range, wait states etc to enter the new voltage range
/// and that the correct sequence is respected (see 'Dynamic voltage scaling management' in RM0440). Also ensure unique
/// access of PWR peripheral
pub(crate) unsafe fn set_boost(enable_boost: bool) {
    let pwr = unsafe { &*PWR::ptr() };
    let r1mode = !enable_boost;
    pwr.cr5.modify(|_r, w| w.r1mode().bit(r1mode));
}
